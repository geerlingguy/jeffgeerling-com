---
nid: 91
title: "Drupal Performance Guide - Drupal and the LAMP/LEMP stack"
slug: "drupal-performance-white-paper"
date: 2010-12-28T20:25:38+00:00
drupal:
  nid: 91
  path: /articles/web-design/2010/drupal-performance-white-paper
  body_format: full_html
  redirects: []
tags:
  - apache
  - drupal
  - drupal planet
  - high-speed
  - lamp
  - mysql
  - performance
  - php
aliases:
  - /articles/web-design/2010/drupal-performance-white-paper
---

<p class="rtecenter">{{< figure src="./lamp-stack-with-drupal.jpg" alt="LAMP Stack with Drupal - Druplicon, Linux, Apache, MySQL, PHP" width="421" height="150" class="blog-image" >}}</p>

<p class="rteleft">Drupal is a scalable, flexible, and open source content management system that is built to run on a variety of server architectures. The only real requirement is that PHP runs on your system. You can run Linux, Microsoft, Mac OS X, etc., along with Apache, IIS, nginx, MariaDB, MySQL, PostgreSQL, etc. if you're willing to do a few extra things.</p>

<p class="rteleft">However, the overwhelming majority of Drupal websites use the most popular LAMP stack on the backend: Linux, Apache, MySQL and PHP, or the 'LEMP' variation, with Nginx instead of Apache. This white paper (which is a living document – I'll be updating it as time progresses) provides my thoughts on performance considerations for Drupal on a LAMP stack, but this information can be used for pretty much any system on any server, if you look at the basic principles.</p>

<p class="rteleft">Sections:</p>

<ol>
	<li class="rteleft"><a href="#front-end">Front End Performance</a></li>
	<li class="rteleft"><a href="#drupal">Drupal Performance</a></li>
	<li class="rteleft"><a href="#apache">Apache Performance</a></li>
	<li class="rteleft"><a href="#php">PHP Performance</a></li>
	<li class="rteleft"><a href="#mysql">MySQL Performance</a></li>
	<li class="rteleft"><a href="#server">Linux/Server Tuning</a></li>
	<li class="rteleft"><a href="#recovery">Disaster/Data Recovery</a></li>
	<li class="rteleft"><a href="#other">Other Tuning/Expanding Horizontally</a></li>
</ol>

<h3><strong><a name="front-end"></a>First - Front End Performance</strong></h3>

<h4>HTML, CSS, Images and JavaScript</h4>

These three technologies rule the web. Almost everything worth doing on the web involves these three languages at some point. There are a ton of things you can do to speed up your website by simply looking at the code generated by your website that reaches the end-user—in fact, you should do this before even <em>thinking</em> about looking at the LAMP stack.

How many elements have to load with each page request? Do you have large or unoptimized image files on your site? Do you use efficient CSS and Javascript? Do you aggregate your CSS and JS files so browsers don't have to download tons of files when they reach your site? Is your HTML well-structured and uncluttered?

There are a few tools you can use to measure the general performance of your site's front-end:

<ul>
	<li><a href="http://yslow.org/">YSlow</a>&nbsp;- great baseline front-end page load benchmarking tool</li>
	<li><a href="https://developers.google.com/speed/pagespeed/insights/">Google PageSpeed&nbsp;Insights</a>&nbsp;- great baseline front-end page load benchmarking tool</li>
	<li><a href="http://gtmetrix.com/">GTMetrix</a> - online page speed analysis and load time waterfall display using PageSpeed and YSlow</li>
	<li><a href="http://www.webpagetest.org/">WebPagetest.org</a> - like GTMetrix, but on steroids with tons more features</li>
	<li><a href="http://tools.pingdom.com/fpt/">Pingdom Website Speed Test</a> - Like GTMetrix and WebPagetest.</li>
</ul>

All of these tools will show you how long it takes to load your page, and give suggestions for how you can improve the load time of the front end of your website.

You'll want to run tests at different times, and from as many different locations as you can (especially if your website is used by a geographically-diverse population).

<h4>Optimizing CSS and JS</h4>

You should use efficient CSS selectors and JavaScript code (using a library like jQuery can help in this regard), and you'll also want to reduce the amount of times you rewrite similar CSS styling rules. You might also consider that <a href="http://www.stevesouders.com/blog/2009/03/10/performance-impact-of-css-selectors/">certain CSS selectors perform worse than others</a>. These are all optimizations that can help the time it takes a browser to <em>render</em> your web page.

But, in terms of practical performance benefits, it's usually more important to make sure you have as few files transferred between your server and a user's computer as possible. Many sites have 20+ files to serve for a first time visitor—it would be better if there were only a few files at most, because each file means more overhead and delay before all the files are downloaded.

Therefore, in Drupal, turn on CSS and JavaScript Aggregation on the performance settings page.

Additionally, you might want to further minify (make smaller) the JavaScript files that are aggregated, and add more optimizations to both the CSS and JS aggregation on your site. You can do this using the <a href="https://www.drupal.org/project/advagg">Advanced CSS/JS Aggregation</a>&nbsp;module for Drupal. This will make files even smaller and more streamlined.

<h4>Optimizing Images</h4>

Many modern themes for websites have images included via the site's CSS files as backgrounds, icons, etc. If this is the case, Drupal's <a href="http://drupal.org/project/css_emimage">CSS Embedded Images</a> module is extremely helpful (in tandem with the CSS Aggregation setting). It will embed the image data in your site's CSS files, so the browser doesn't have to download all the extra images separately.

If you don't want to use the CSS Embedded Images module, another great technique is using CSS image sprites or SVGs instead of having multiple JPG/PNG/GIF resources. I don't have adequate space to describe how to make image sprites or deal with SVGs here, but a few Google searches should get you up to speed.

For other images you use on your website (like those embedded in a page or a node, or uploaded using the FileField or ImageField module), there are more optimizations you can do to make sure no extraneous data is being downloaded by your site's visitors:

<ul>
	<li>Yahoo's <a href="http://www.smushit.com/ysmush.it/">Smush.it</a> tool allows you to squeeze the fat out of image files (JPEGs, GIFs, and PNG files), and make sure no extra bytes are left on a file as a result of a bad compression technique in your image editor.</li>
	<li>You can do a similar thing on your computer for PNG images with <a href="http://imageoptim.pornel.net/">ImageOptim</a> (for Mac), <a href="http://optipng.sourceforge.net/">OptiPNG</a> (*nix), or <a href="http://www.ardfry.com/pngoutwin/">PNGOUTWin</a> (for Windows).</li>
	<li>The&nbsp;<a href="http://drupal.org/project/image_resize_filter">Image Resize Filter</a> module uses an image's real size and the size of the image in a node/block/wherever and make a smaller-resolution file if the image has been resized by the user (ever loaded a site and waited a minute for a tiny graphic to load because it's actually a 5 MB JPG?).</li>
</ul>

<h4>CDNs, More Concurrent Downloads</h4>

A simple way to speed up the front-end performance of your site (besides simply limiting the number of files that need to be downloaded to make your theme look nice) is to make a faux-CDN using something like Drupal's <a href="https://www.drupal.org/project/cdn">CDN</a> module or some other technique.

This will allow browsers to download more resources at a time (browsers typically only download 2-4 files concurrently from a single domain, like <em>example.com</em>). If you configure your server correctly, you can set it so that file resources and such don't have any associated cookies, and could even be served on a different server like lighttpd or nginx.

You can also employ a 'real' CDN or a separate server (many people use Amazon or CloudFlare) to cache files closer to site end users, and have them served more directly to your site's users, without the request even needing to be sent to your webserver. This allows your server to concentrate only on building pages and serving dynamic data and resources—files, stylesheets and CSS files are changed infrequently, and can be served off-site to allow a web browser to load a full page faster.

<h3><strong><a name="drupal"></a>Second - Drupal Performance</strong></h3>

One of the first things that you should do on your Drupal site (or any site that has a modular architecture) is re-evaluate whether you need all the modules/plugins/theme features you have installed. Is this site pretty much set in stone, design-wise? Do you still need Views UI, theme helpers, etc. clogging up page loads and caches?

Most Drupal websites could gain quite a bit of speed by simply cutting down the modules in use by a third, or even a half. And, typically, users will be happier—especially if some of the superfluous features were slowing down their browsing! Watch out especially for modules like the statistics module and watchdog. While their features may be nice to have, they can be database performance hogs. You should always see if there's an easier or better way to achieve what a particular module does. For example, rather than enable Statistics, use <a href="http://www.google.com/analytics/">Google Analytics</a> on your site, or another stat tracker to see how many people visit your site. And rather than watchdog, use Syslog and view logged messages on your server directly.

<h4>Drupal Performance Measurement</h4>

To get an understanding of what pages take longer to load than others, what particular database queries take a long time, or to keep a log/history of page performance over time, look no further than the robust <a href="http://drupal.org/project/devel">Devel</a> module. I have it installed on all my sites, though I disable it when I'm not using the development tools or performance monitoring actively.

The <a href="http://drupal.org/project/views">Views</a> module (which I use on most every site I've ever built, because it's so darn versatile, and fairly optimized out of the box) has a built-in performance monitoring tool—if you preview your view in Views' edit mode, you can see the time it took to get the database results, and the time it took Views to render that data, below the preview of your Views output.

The Drupal handbook has more <a href="http://drupal.org/project/views">server tuning considerations</a> to read, but I'll be covering many of those considerations in later parts of this white paper (especially server/software tuning).

<h4>Caching is Your Best Ally</h4>

Using any content management system means you have content stored in some sort of database that must be retrieved and displayed to the end user. This means there are many steps involved, all of which can be sped up to deliver better site performance. Drupal has to connect to the database. The database has to retrieve the data, and send it to PHP. PHP/Drupal has to process this data, make it look nice, then present the results to Apache. Apache sends the data to the end user.

On every single level of your website/server, you can avoid the overhead of retrieving, processing, and sending data by using different caching mechanisms. Caching basically means storing the result of some previous operation so that the operation doesn't need to be run again to get the same data. And it helps. A lot.

At the most basic level, turn on Drupal's built-in page cache (<a href="http://drupal.org/node/326504">read more here</a>). If you can avoid using any modules that don't work with Aggressive caching, turn on Aggressive caching. Normal caching will help, too. When an anonymous user goes to a page on your site, Drupal needs only to retrieve the page from a special cache, already rendered, rather than go through the whole process of building the page again.

Stepping it up a notch, if you have mostly anonymous user traffic on your site, you can give your site hundreds or thousands of times higher performance and capacity by simply using a cache system like <a href="http://drupal.org/project/Varnish">Varnish</a> or <a href="http://drupal.org/project/boost">Boost</a>. These systems don't even require Drupal, PHP, or MySQL to do any work at all, because an actual file is saved and served up to the end user outside of the database.

I use Boost on most of my simple/smaller sites, and it even works on shared hosting—you simply add a bit of code to your website's .htaccess file (more on that later), then configure Boost to save pages to your server's filesystem. Boost will then help Apache to serve the files directly rather than call on Drupal to serve the files, saving your server from doing a TON of work.

If you want to get started with Varnish, there are a lot of great tutorials, but one of the latest and most complete is this presentation from Tree House Agency, <a href="http://prezi.com/lgk2q71ez9iv/coat-your-website-in-varnish-maryland/">Coat Your Website in Varnish</a>.

Going a little deeper, we can do a few things to speed up caches that are normally served by MySQL by using dedicated caching mechanisms like <a href="http://drupal.org/project/memcache">memcached</a> or <a href="https://www.drupal.org/project/redis">Redis</a>. These modules tie into server-side caching systems that store frequently-accessed pages and database results in your server's memory, meaning the server can get this information more quickly, and this even increases performance logged-in users. I'll talk a little more about the server-side use of these tools later.

Views, Blocks, and Panels also have built-in caching mechanisms. At a minimum, you should turn on time-based caching for almost any view or panel on a site, except in specific circumstances where it wouldn't make sense (e.g. an up-to-the-moment stock ticker or something of that nature).

<h4>Offloading Services</h4>

Three Drupal features that are used on most every site stand out as easy candidates for using external services or integrations instead of the built-in solution:

<ul>
	<li>Use Google Analytics (mentioned above) or another stat tracker instead of Statistics/Tracker modules.</li>
	<li>Use <a href="http://drupal.org/handbook/modules/syslog">Syslog</a> instead of Watchdog/DBLog. If you need a pretty front-end to your logs, consider using something like <a href="https://www.elastic.co/products">ELK</a> to visualize and search log entries.</li>
	<li>Use <a href="http://drupal.org/project/apachesolr">Apache Solr Search</a> (or <a href="https://www.drupal.org/project/search_api_solr">Search API Solr</a>) instead of built-in search. (Note: I also run <a href="https://hostedapachesolr.com/">Hosted Apache Solr for Drupal</a>, which is an inexpensive hosted Solr search provider, if you can't install Solr on your own server).</li>
</ul>

<h3><strong><a name="apache"></a>Third - Apache Performance</strong></h3>

.htaccess rules - Etags, etc.

httpd.conf tuning - max connections, max connections per child

Alternatives to Apache - nginx, lighttpd

<h3><strong><a name="php"></a>Fourth - PHP Performance</strong></h3>

Opcache, APC cache.

XHProf

XDebug

HipHop/HHVM/PHP7

<h3><a name="mysql"></a><strong>Fifth - MySQL Performance</strong></h3>

MySQL gets trashed a lot these days because people think NoSQL-style data storage is blazing fast (comparatively), and MySQL and other relational databases are dated. MySQL doesn't have to be slow, though, and many millions of users are quite satisfied with its speed and reliability. There are a few things you can (and should) do to speed up database access before jumping on the NoSQL bandwagon, or dumping MySQL for the latest version of PostgreSQL or MariaDB. It might save you a ton of time and hassle.

<h4>Tune your queries</h4>

If you do nothing else, simply monitoring query performance and tuning your individual queries will get you very far—especially on lower-traffic sites. Often times, by changing the structure of a query, you'll be able to radically speed up the query. Using MySQL's EXPLAIN feature and the <code>slow_query_log</code> is very helpful here.

Additionally enable the Devel module's query log while you're developing your site so you can see a list of every query and the time the query took to complete at the bottom of every page on the site. This is a quick and easy way to see from where queries are coming, and how long they're taking. It also helps to see if there are a lot of duplicate queries on a page—that's one place a query cache comes in handy.

<h4>Use Indexes Properly</h4>

TODO

<h4>Use replication</h4>

TODO

<h4>Eliminate Disk I/O Contention</h4>

Much of the slowness associated with SQL queries (especially those with complex table joins, involving temporary table creation that requires writes to the disk) is caused because of the relative slowness of hard disk I/O (even with SSD storage). Hard drives are thousands of times slower reading and writing data than RAM. There are a few things you can do to greatly speed up disk access (besides simply caching things in RAM or using memcached... you have to hit the hard drive sometimes!):

<ul>
	<li>Move database files to another drive on your system.</li>
	<li>Use an SSD (either as a dedicated database drive, or as your system's main drive—make sure you back it up or have it in a RAID array, though! SSDs can fail just like normal spinning drives). Solid State Disks are still slower than RAM, but they're <em>much</em> faster than hard drives, especially for random reads and writes—this is a huge boon for database access!</li>
	<li>Use a RAID array instead of a single disk. Using RAID 0 or RAID 10 will give you a much faster disk system than using a single drive. If using a non-mirrored RAID array (like RAID 0, which I don't really recommend), make sure you backup or use master-master replication so you always have a hot copy of the database in case of failure. Hard drives fail often, and at the worst possible moment.</li>
</ul>

<h4>Know Your Table Structures</h4>

One time, when I was importing a huge dataset into a new Drupal site (on a server with a super fast SSD), I noticed that switching the tables from InnoDB to MyISAM sped things up a very large amount. It turns out that InnoDB actually logs every row it writes to disk, and does some other row-level and transaction-level accounting that slows things down considerably if configured incorrectly.

When you're just adding data here and there (like normal site operation), that's a good thing, and row-level locking is one of the nice advantages of using InnoDB tables. However, when importing huge amounts of data, you might want to consider following some of these <a href="http://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb.html">InnoDB Performance Tuning Tips</a> suggested by MySQL.

<h4>Tune your my.cnf file</h4>

Find your system's my.cnf file, and tune the following settings (others may need tweaking as well, depending on your circumstances) for Drupal:

<ul>
	<li><code>innodb_buffer_pool_size</code> (if you have room, try to set this to 1.5x the size of your Drupal database, so all or most of the database reads can be performed in RAM)</li>
	<li><code>key_buffer_size</code> (for MyISAM index cache)</li>
	<li><code>query_cache_size</code> (usually helpful for environments with mostly reads)</li>
	<li><code>thread_cache</code></li>
	<li><code>table_cache</code></li>
	<li><code>innodb_log_file_size</code> / innodb_log_buffer_size</code></li>
	<li><code>sort_buffer_size</code>, <code>join_buffer_size</code>, <code>read_buffer_size</code></li>
	<li><code>tmp_table_size</code></li>
</ul>

<h4>Use Memcached or Redis</h4>

<a href="http://memcached.org/">Memcached</a> is a blazing-fast in-memory caching backend that can be used to cache database results, and avoid expensive and slow database queries. There's a <a href="http://drupal.org/project/memcache">Drupal module for Memcached</a>, and it's not too hard to set up.

Alternatively, you can use <a href="https://www.drupal.org/project/redis">Redis</a>, which is about as reliable and fast as Memcached for most Drupal sites.

<h3><strong><a name="server"></a>Sixth - Linux/Server Tuning</strong></h3>

SSD Drives, increase RAM, RAID array

Processor, Network Interface

Munin/Cacti as essential monitoring tool

<h3><a name="recovery"></a><strong>Seventh - Disaster/Data Recovery</strong></h3>

What's the slowest kind of website? One that doesn't load.

It happens to everyone at some point or another—no matter how many redundant servers and failover plans you have, no matter how many data centers you're housed inside, no matter what CDN you use, you're going to have your website go down or your data become corrupted at some point.

It's a good idea to make a great data/disaster recovery plan, and practice implementing it. This is universal to all IT operations—but is especially important in web development, because many websites translate minutes of downtime or lost data into hundreds or thousands of lost dollars or mindshare.

This could actually be the first line-item in your list of critical issues to tackle for any important website. But this white paper is more about the front-end performance of the website, and less about stability, backup, etc. I'll still write a little bit about some of my favorite tools and methods for backup and recovery in Drupal—some I use on almost every website; others I use on the more mission-critical sites.

Backup and Restore module

Shell script backups, cPanel backups, drush sync

Multiple data locations, multiple backups, non-electronic backups (EMP recovery).

<h3><strong><a name="other"></a>Meta - Other Tuning, Expanding Horizontally</strong></h3>

Operating in the Cloud

Amazon EC2, S3, CDNs, etc.

Memcached clusters, Solr clusters, MySQL clusters, etc.
